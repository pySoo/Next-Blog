---
title: React의 Reconciliation (Fiber)
description: React의 Reconciliation 알고리즘과 Fiber 아키텍처에 대해 알아보겠습니다.
image: '/posts/12-suspense-errorboundary/240304-055427.png'
tags:
  - React
  - Reconciliation
  - Fiber
date: 2024-08-04 18:16:05
draft: true
---

> ## 글을 시작하며

React로 개발을 해보셨다면 리스트 형식의 컴포넌트를 렌더링할 때 key 값을 설정해주지 않으면 에러가 발생하는 것을 경험해보셨을 것입니다.
왜 key를 설정해주지 않으면 에러가 발생할까요?

지금부터 그 이유를 React의 렌더링 과정과 Reconciliation 알고리즘과 함께 알아보겠습니다.

## React의 렌더링

React의 컴포넌트는 언제 렌더링이 될까요?

- 컴포넌트의 props나 state가 변경되었을 때
- 부모 컴포넌트가 렌더링되었을 때
- key 값이 변경되었을 때

그렇다면 변경된 부분을 어떻게 감지할 수 있는 걸까요?

React는 Virtual DOM을 사용하여 변경된 부분을 감지합니다.
마지막으로 렌더링 된 VDOM과(Current Tree) props, state가 변경된 VDOM을(Work In Progress Tree) 비교하여 변경된 부분만 실제 DOM에 반영하여 렌더링합니다.

이러한 과정을 재조정(Reconciliation)이라고 합니다.

## Reconciliation 과정

그렇다면 Reconciliation은 어떻게 이루어질까요?
두 VDOM을 어떻게 비교할 수 있는지 생각해보겠습니다.

VDOM은 트리 구조로 이루어져 있습니다.
두 트리를 비교하기 위해서는 모든 노드를 순회하면서 비교해야 합니다.
이러한 순회의 시간복잡도는 O(n^3)이 되기 때문에 비효율적입니다.

따라서 React 팀은 O(n)의 시간 복잡도를 가진 diffing 알고리즘을 개발하였습니다.

diffing 알고리즘은 조정자를 사용해서 두 트리간의 차이점을 찾습니다.

### 조정자

- React 16 이전: Stack Reconciler (재귀 호출, 동기적 렌더링)
- React 16 이후: Fiber Reconciler (비동기적 렌더링)

새로운 기술은 이전 기술의 한계를 극복하기 위해 나온 것입니다.
그렇다면 Fiber Reconciler는 어떤 문제를 해결하기 위해 등장했을까요?

## Fiber Reconciler

Fiber 이전의 Stack Reconciler는 렌더링이 시작되면 끝날 때까지 다른 작업을 수행할 수 없었습니다.

만약 컴포넌트가 렌더링 되는 중에 유저의 클릭 이벤트가 발생한다면 어떤 작업이 먼저 실행될까요?
유저는 클릭 이벤트가 먼저 실행되기를 기대하지만, 렌더링 작업이 끝날 때까지 클릭 이벤트를 처리할 수 없습니다.

Fiber는 이러한 문제를 우선순위를 이용하여 해결하였습니다.
우선순위가 높은 작업이 있다면 현재 작업을 잠시 멈추고 나중에 다시 작업합니다.

그렇다면 어떻게 이러한 우선순위 개념을 구현해낸 것일까요?

### Fiber 구조

잠시 자바스크립트의 동작 방식에 대해 알아보겠습니다.
자바스크립트는 한 번에 하나의 일만 수행할 수 있는 싱글 스레드 언어입니다.

자바스크립트 코드를 실행하면 코드들에 대한 실행 컨텍스트를 생성하고 이를 콜 스택에 쌓아서 작업을 수행합니다.
하지만 예외적으로 setTimeout, Promise와 같은 비동기 작업은 매크로 태스크 큐, 마이크로 태스크 큐에 보관됩니다.

이벤트 루프는 콜 스택이 비어있을 때 태스크 큐에 있는 작업을 콜 스택으로 옮겨 실행합니다.
이벤트 루프의 역할 덕분에 싱글 스레드인 자바스크립트가 오래 걸리는 비동기 작업을 처리할 수 있게 됩니다.

Fiber는 이러한 콜스택을 가상으로 구현하여 우선순위를 관리합니다.
더 높은 우선순위의 작업이 있다면 현재 작업을 멈추고 (포인터로 기억) 다른 작업을 먼저 수행하도록 콜스택을 조정합니다.

## React key 설정 예제

```tsx
function List() {
  return (
    <ul>
      <li>안</li>
      <li>녕</li>
      <li>하</li>
      <li>세</li>
      <li>요</li>
    </ul>
  );
}
```

아래의 노드를 Fiber 객체로 분리해보겠습니다.

```
ul
// type: 'ul' / sibling: null / return 부모Fiber / child: li1 ('안')
  li1 ('안')
  // type: 'li' / sibling: li2 / return ulFiber / child: null
  li2 ('녕')
  // type: 'li' / sibling: li3 / return ulFiber / child: null
  li3 ('하')
  // type: 'li' / sibling: li4 / return ulFiber / child: null
  li4 ('세')
  // type: 'li' / sibling: li5 / return ulFiber / child: null
  li5 ('요')
  // type: 'li' / sibling: null / return ulFiber / child: null
```

예시 코드에서는 key를 설정하지 않았기 때문에 fiber의 key는 null로 설정됩니다.
key가 설정되어 있지 않으면 React는 index를 key로 사용합니다.

React Fiber은 재사용 가능한 것은 최대한 재사용을 하는 것이 목적입니다.
만약 state나 props의 변경으로 업데이트가 진행된다면 Reconciler는 Fiber를 재사용할지, 교체할지 결정합니다.

이 때 엘리먼트의 type이나 key가 이전과 다르다면 Fiber를 교체합니다.

단순히 배열의 마지막에 요소가 추가된다면 문제가 없겠지만,
같은 엘리먼트 type을 가지고 배열 사이에 요소가 추가되거나 삭제된다면 문제가 발생할 수 있습니다.
이러한 경우 key로 설정된 index가 변경되기 때문에 Reconciler는 하위 노드들을 모두 교체합니다.
